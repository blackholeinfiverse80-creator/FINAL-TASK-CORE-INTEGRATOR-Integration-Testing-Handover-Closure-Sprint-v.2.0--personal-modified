#!/usr/bin/env python3
"""
Day 1 - Integration Verification Script
Core Integrator v1.0.0 - Production Ready

Tests all integration modes:
- SQLite only
- MongoDB enabled  
- Noopur enabled/disabled
- Validates /system/health and /system/diagnostics
- Confirms integration_ready determinism
- Verifies feedback flow rejection
"""

import json
import os
import sys
import time
import requests
import subprocess
from pathlib import Path
from typing import Dict, Any, List
from datetime import datetime

class IntegrationVerifier:
    def __init__(self):
        self.base_url = "http://localhost:8001"
        self.results = {}
        self.artifacts_dir = Path("verification_artifacts")
        self.artifacts_dir.mkdir(exist_ok=True)
        
    def log(self, message: str):
        timestamp = datetime.now().strftime("%H:%M:%S")
        print(f"[{timestamp}] {message}")
        
    def save_artifact(self, name: str, data: Any):
        """Save JSON artifact"""
        artifact_path = self.artifacts_dir / f"{name}.json"
        with open(artifact_path, 'w') as f:
            json.dump(data, f, indent=2, default=str)
        self.log(f"Saved artifact: {artifact_path}")
        
    def wait_for_server(self, timeout: int = 30) -> bool:
        """Wait for server to be ready"""
        self.log("Waiting for server to start...")
        for i in range(timeout):
            try:
                response = requests.get(f"{self.base_url}/", timeout=5)
                if response.status_code == 200:
                    self.log("Server is ready")
                    return True
            except requests.exceptions.RequestException:
                pass
            time.sleep(1)
        return False
        
    def test_endpoint(self, endpoint: str, method: str = "GET", data: Dict = None) -> Dict[str, Any]:
        """Test an endpoint and return structured result"""
        url = f"{self.base_url}{endpoint}"
        try:
            if method == "GET":
                response = requests.get(url, timeout=10)
            elif method == "POST":
                response = requests.post(url, json=data, timeout=10)
            
            result = {
                "endpoint": endpoint,
                "method": method,
                "status_code": response.status_code,
                "success": response.status_code < 400,
                "response_time_ms": int(response.elapsed.total_seconds() * 1000),
                "timestamp": datetime.utcnow().isoformat() + 'Z'
            }
            
            try:
                result["response_data"] = response.json()
            except:
                result["response_data"] = response.text
                
        except Exception as e:
            result = {
                "endpoint": endpoint,
                "method": method,
                "success": False,
                "error": str(e),
                "timestamp": datetime.utcnow().isoformat() + 'Z'
            }
            
        return result
        
    def update_env_config(self, config: Dict[str, str]):
        """Update .env file with new configuration"""
        env_path = Path(".env")
        
        # Read current .env
        current_config = {}
        if env_path.exists():
            with open(env_path, 'r') as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#') and '=' in line:
                        key, value = line.split('=', 1)
                        current_config[key] = value
        
        # Update with new config
        current_config.update(config)
        
        # Write back
        with open(env_path, 'w') as f:
            f.write("# Core Integrator Configuration - Integration Testing\n")
            f.write("# Auto-generated by integration_verification.py\n\n")
            for key, value in current_config.items():
                f.write(f"{key}={value}\n")
                
        self.log(f"Updated .env with: {config}")
        
    def start_server_process(self) -> subprocess.Popen:
        """Start the server process"""
        self.log("Starting Core Integrator server...")
        return subprocess.Popen(
            [sys.executable, "main.py"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        
    def test_configuration(self, config_name: str, env_config: Dict[str, str]) -> Dict[str, Any]:
        """Test a specific configuration"""
        self.log(f"\n=== Testing Configuration: {config_name} ===")
        
        # Update configuration
        self.update_env_config(env_config)
        
        # Start server
        server_process = self.start_server_process()
        
        try:
            # Wait for server to be ready
            if not self.wait_for_server():
                return {
                    "config_name": config_name,
                    "success": False,
                    "error": "Server failed to start within timeout"
                }
            
            # Test endpoints
            results = {
                "config_name": config_name,
                "env_config": env_config,
                "timestamp": datetime.utcnow().isoformat() + 'Z',
                "endpoints": {}
            }
            
            # Test /system/health
            health_result = self.test_endpoint("/system/health")
            results["endpoints"]["health"] = health_result
            
            # Test /system/diagnostics  
            diagnostics_result = self.test_endpoint("/system/diagnostics")
            results["endpoints"]["diagnostics"] = diagnostics_result
            
            # Test /core endpoint
            core_test_data = {
                "module": "finance",
                "intent": "analyze",
                "user_id": "test_user_integration",
                "data": {"query": "test integration"}
            }
            core_result = self.test_endpoint("/core", "POST", core_test_data)
            results["endpoints"]["core"] = core_result
            
            # Test feedback endpoint with invalid schema
            invalid_feedback = {
                "user_id": "test_user",
                "generation_id": "invalid_format",  # Should be UUID
                "feedback_type": "invalid_type",    # Should be thumbs_up/thumbs_down
                "content": "test feedback"
            }
            feedback_result = self.test_endpoint("/feedback", "POST", invalid_feedback)
            results["endpoints"]["feedback_invalid"] = feedback_result
            
            # Extract key metrics
            if health_result.get("success") and "response_data" in health_result:
                health_data = health_result["response_data"]
                results["health_status"] = health_data.get("status")
                results["components"] = health_data.get("components", {})
                
            if diagnostics_result.get("success") and "response_data" in diagnostics_result:
                diag_data = diagnostics_result["response_data"]
                results["integration_ready"] = diag_data.get("integration_ready")
                results["integration_score"] = diag_data.get("integration_score")
                results["failing_components"] = diag_data.get("failing_components", [])
                
            results["success"] = all(
                r.get("success", False) for r in results["endpoints"].values()
                if r["endpoint"] != "/feedback"  # Feedback should fail with invalid schema
            )
            
            # Verify feedback rejection
            if feedback_result.get("status_code") in [400, 422]:
                results["feedback_rejection_working"] = True
            else:
                results["feedback_rejection_working"] = False
                
        finally:
            # Stop server
            server_process.terminate()
            try:
                server_process.wait(timeout=10)
            except subprocess.TimeoutExpired:
                server_process.kill()
                server_process.wait()
            self.log(f"Server stopped for {config_name}")
            
        return results
        
    def test_determinism(self) -> Dict[str, Any]:
        """Test integration_ready determinism by running same config multiple times"""
        self.log("\n=== Testing integration_ready Determinism ===")
        
        config = {
            "USE_MONGODB": "false",
            "INTEGRATOR_USE_NOOPUR": "false",
            "SSPL_ENABLED": "true"
        }
        
        results = []
        for i in range(3):
            self.log(f"Determinism test run {i+1}/3")
            result = self.test_configuration(f"determinism_run_{i+1}", config)
            
            # Extract just the integration_ready status
            determinism_data = {
                "run": i+1,
                "integration_ready": result.get("integration_ready"),
                "integration_score": result.get("integration_score"),
                "health_status": result.get("health_status"),
                "timestamp": result.get("timestamp")
            }
            results.append(determinism_data)
            
        # Check if all runs produced same results
        first_ready = results[0]["integration_ready"]
        first_score = results[0]["integration_score"]
        
        deterministic = all(
            r["integration_ready"] == first_ready and 
            r["integration_score"] == first_score 
            for r in results
        )
        
        return {
            "deterministic": deterministic,
            "runs": results,
            "summary": f"integration_ready: {first_ready}, score: {first_score}, consistent: {deterministic}"
        }
        
    def run_verification(self):
        """Run complete integration verification"""
        self.log("Starting Core Integrator Integration Verification")
        self.log("=" * 60)
        
        # Test configurations
        configurations = [
            {
                "name": "sqlite_only",
                "config": {
                    "USE_MONGODB": "false",
                    "INTEGRATOR_USE_NOOPUR": "false", 
                    "SSPL_ENABLED": "true"
                }
            },
            {
                "name": "mongodb_enabled",
                "config": {
                    "USE_MONGODB": "true",
                    "MONGODB_CONNECTION_STRING": "mongodb://localhost:27017",
                    "MONGODB_DATABASE_NAME": "core_integrator_test",
                    "INTEGRATOR_USE_NOOPUR": "false",
                    "SSPL_ENABLED": "true"
                }
            },
            {
                "name": "noopur_enabled",
                "config": {
                    "USE_MONGODB": "false",
                    "INTEGRATOR_USE_NOOPUR": "true",
                    "NOOPUR_BASE_URL": "http://localhost:5001",
                    "SSPL_ENABLED": "true"
                }
            },
            {
                "name": "all_integrations",
                "config": {
                    "USE_MONGODB": "true", 
                    "MONGODB_CONNECTION_STRING": "mongodb://localhost:27017",
                    "MONGODB_DATABASE_NAME": "core_integrator_test",
                    "INTEGRATOR_USE_NOOPUR": "true",
                    "NOOPUR_BASE_URL": "http://localhost:5001",
                    "SSPL_ENABLED": "true"
                }
            }
        ]
        
        # Run tests for each configuration
        config_results = []
        for config_spec in configurations:
            result = self.test_configuration(config_spec["name"], config_spec["config"])
            config_results.append(result)
            self.save_artifact(f"config_{config_spec['name']}", result)
            
        # Test determinism
        determinism_result = self.test_determinism()
        self.save_artifact("determinism_test", determinism_result)
        
        # Generate summary report
        summary = {
            "verification_timestamp": datetime.utcnow().isoformat() + 'Z',
            "total_configurations": len(configurations),
            "successful_configurations": sum(1 for r in config_results if r.get("success", False)),
            "determinism_test": determinism_result,
            "configuration_results": config_results,
            "artifacts_location": str(self.artifacts_dir)
        }
        
        self.save_artifact("integration_verification_summary", summary)
        
        # Print summary
        self.log("\n" + "=" * 60)
        self.log("INTEGRATION VERIFICATION COMPLETE")
        self.log("=" * 60)
        self.log(f"Configurations tested: {summary['total_configurations']}")
        self.log(f"Successful: {summary['successful_configurations']}")
        self.log(f"Determinism test: {'PASS' if determinism_result['deterministic'] else 'FAIL'}")
        self.log(f"Artifacts saved to: {self.artifacts_dir}")
        
        return summary

if __name__ == "__main__":
    verifier = IntegrationVerifier()
    verifier.run_verification()